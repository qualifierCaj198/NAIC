name: Deploy to Vultr with HTTPS (password SSH)

on:
  push:
    branches: [ "main" ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create deploy archive (git archive avoids live-file races)
        run: |
          git archive --format=tar.gz -o naic_${{ github.sha }}.tar.gz HEAD

      - name: Upload archive to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          password: ${{ secrets.SSH_PASSWORD }}
          source: "naic_${{ github.sha }}.tar.gz"
          target: "${{ secrets.APP_DIR }}/releases/"

      - name: Remote deploy & HTTPS setup
        uses: appleboy/ssh-action@v1.2.0
        env:
          APP_DIR: ${{ secrets.APP_DIR }}
          SERVER_NAME: ${{ secrets.SERVER_NAME }}
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          password: ${{ secrets.SSH_PASSWORD }}
          script_stop: true
          envs: GITHUB_SHA,APP_DIR,SERVER_NAME,LETSENCRYPT_EMAIL
          script: |
            set -euo pipefail
            GITHUB_SHA="${{ github.sha }}"
            APP_DIR="${APP_DIR:-/opt/naic}"
            SERVER_NAME="${SERVER_NAME:-_}"
            LETSENCRYPT_EMAIL="${LETSENCRYPT_EMAIL:-admin@example.com}"

            # Base packages
            apt-get update
            DEBIAN_FRONTEND=noninteractive apt-get install -y python3 python3-venv python3-pip nginx git ufw certbot python3-certbot-nginx curl procps

            # UFW rules
            ufw allow OpenSSH || true
            ufw allow 'Nginx Full' || true
            ufw --force enable || true

            mkdir -p "$APP_DIR/releases" "$APP_DIR/shared"
            ARCHIVE="$APP_DIR/releases/naic_${GITHUB_SHA}.tar.gz"
            if [ ! -f "$ARCHIVE" ]; then echo "Archive not found: $ARCHIVE"; exit 1; fi

            # Unpack new release
            rm -rf "$APP_DIR/app.new"
            mkdir -p "$APP_DIR/app.new"
            tar -xzf "$ARCHIVE" -C "$APP_DIR/app.new"

            # Activate release
            rm -rf "$APP_DIR/app.prev"
            if [ -d "$APP_DIR/app" ]; then mv "$APP_DIR/app" "$APP_DIR/app.prev"; fi
            mv "$APP_DIR/app.new" "$APP_DIR/app"

            # Python venv + deps
            cd "$APP_DIR/app"
            if [ ! -d ".venv" ]; then python3 -m venv .venv; fi
            . .venv/bin/activate
            python -m pip install --upgrade pip setuptools wheel
            pip install -r requirements.txt
            pip install gunicorn

            # -------------------------
            # systemd service (write to tmp, sanitize, install)
            # -------------------------
            SERVICE_FILE_TMP="$(mktemp)"
            cat > "$SERVICE_FILE_TMP" <<'EOF'
            [Unit]
            Description=NAIC Flask app (gunicorn)
            After=network.target

            [Service]
            User=root
            Group=root
            WorkingDirectory=/opt/naic/app
            Environment=PYTHONUNBUFFERED=1
            Environment=PYTHONPATH=/opt/naic/app
            Environment=PATH=/opt/naic/app/.venv/bin
            ExecStart=/opt/naic/app/.venv/bin/gunicorn \
              --workers 3 \
              --worker-class gthread \
              --threads 8 \
              --bind 127.0.0.1:8000 \
              --timeout 120 \
              --graceful-timeout 30 \
              --access-logfile - \
              --error-logfile - \
              app:app
            Restart=always
            RestartSec=3

            [Install]
            WantedBy=multi-user.target
            EOF

            # strip any injected DRONE_* lines + leading blanks
            awk 'BEGIN{seen=0} !/^DRONE_/ { if(!seen){ if($0 ~ /^[[:space:]]*$/){ next } else { seen=1 } } print }' "$SERVICE_FILE_TMP" > "${SERVICE_FILE_TMP}.clean"
            install -m 0644 "${SERVICE_FILE_TMP}.clean" /etc/systemd/system/naic.service
            rm -f "$SERVICE_FILE_TMP" "${SERVICE_FILE_TMP}.clean"

            systemctl daemon-reload
            systemctl enable naic
            systemctl restart naic

            # Quick backend checks before nginx
            sleep 2
            echo "== systemctl status naic =="
            systemctl --no-pager --full status naic || true
            echo "== last 200 lines of journal for naic =="
            journalctl -u naic --no-pager -n 200 || true
            echo "== listening on 8000? =="
            ss -lntp | grep ':8000' || true
            echo "== curl backend HEAD =="
            curl -sS -D - -o /dev/null http://127.0.0.1:8000/ || true

            # -------------------------
            # Nginx site (HTTP first)
            # -------------------------
            NGINX_SITE_TMP="$(mktemp)"
            cat > "$NGINX_SITE_TMP" <<'EOF'
            server {
                listen 80 default_server;
                server_name _;

                access_log /var/log/nginx/naic_access.log;
                error_log  /var/log/nginx/naic_error.log;

                location / {
                    proxy_pass         http://127.0.0.1:8000;
                    proxy_set_header   Host $host;
                    proxy_set_header   X-Real-IP $remote_addr;
                    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header   X-Forwarded-Proto $scheme;
                }
            }
            EOF

            awk 'BEGIN{seen=0} !/^DRONE_/ { if(!seen){ if($0 ~ /^[[:space:]]*$/){ next } else { seen=1 } } print }' "$NGINX_SITE_TMP" > "${NGINX_SITE_TMP}.clean"
            NGINX_SITE="/etc/nginx/sites-available/naic"
            install -m 0644 "${NGINX_SITE_TMP}.clean" "$NGINX_SITE"
            rm -f "$NGINX_SITE_TMP" "${NGINX_SITE_TMP}.clean"

            # ensure only our site is enabled and is the default
            rm -f /etc/nginx/sites-enabled/default || true
            rm -f /etc/nginx/sites-enabled/naic || true
            ln -s "$NGINX_SITE" /etc/nginx/sites-enabled/naic

            nginx -t
            systemctl reload nginx

            # If a real domain is supplied, obtain cert and enable HTTPS + redirect
            if [ "$SERVER_NAME" != "_" ] && [ "$SERVER_NAME" != "localhost" ] && [ -n "$SERVER_NAME" ]; then
              sed -i "s/server_name _;/server_name ${SERVER_NAME};/" "$NGINX_SITE"
              nginx -t && systemctl reload nginx
              certbot --nginx -d "$SERVER_NAME" --non-interactive --agree-tos -m "$LETSENCRYPT_EMAIL" --redirect || true
              nginx -t && systemctl reload nginx
            fi

            echo "== final systemctl status =="
            systemctl --no-pager --full status naic || true
            echo "== final nginx test =="
            nginx -t || true
